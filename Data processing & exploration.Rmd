---
title: "Data processing & exploration"
output: html_notebook
---

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(geosphere)
library(tools)
library(gridExtra)
library(RColorBrewer)
source("define functions.r")
options(dplyr.show_progress = FALSE)
options(scipen=999)
```
### Importing and pre-processing the data
First we load two datasets: 

1. AIS measurements captured within a 15km radius of Las Palmas.
2. Vessel-information data.

During the import process we already remove invalid and insufficient
measurements (e.g. duplicate data). This affected aproximately 12% of the data 
imported. Each measurement is then labelled with a new position id to make each 
data row uniquely identifiable (*POSID*).

*Note: (1) Had already seen some pre-processing in R and QGIS. (2) Was scraped from Marinetraffic and then made tidy using regular expressions.*
```{r, echo=TRUE, message=FALSE, warning=FALSE, results=FALSE}
vesseldetails <- read_csv('dataset/Finals/df_vesseldetails.csv')
aisdata <- read_csv('dataset/Finals/df_1d_selection_restricted.csv') 
tmp_noimp <-  nrow(aisdata)
aisdata <- aisdata %>% 
  subset(select = -c(1,2)) %>% 
  filter(MMSI %in% vesseldetails$MMSI) %>%
  subset(!duplicated(select(.,MMSI,TIMESTAMP))) %>% 
  group_by(MMSI) %>% 
  filter(n() > 10) %>% 
  ungroup() %>%
  arrange(MMSI,TIMESTAMP) %>% 
  mutate(POSID = row_number(x = .$MMSI))
cat(' Number of AIS measurements available:',tmp_noimp,
    '\n','Number of valid AIS measurements imported:', nrow(aisdata))
```

### Create tracks and detect trips
The plot below shows three different representations of the AIS data. In the 
'Points' plot on the left we see the orignal data representation: a collection 
of GPS coordinates pertaining to a particular vessel.

In the 'Tracks' plot in the center the points have been transformed into a 
navigationpath where segments are connected in chronological order. Moreover 
both for the overall track as well as each segment characteristic are computed. 
E.g. the duration or length of a segment. These transformations are implemented 
within the `Points2Trajectory()` function below.

On the right plot further transformations were carried out. Here a vessel's 
trajectory is broken up into two 'trips' which occured on two different days. 
The trip colored in red occured on the 5th of June 2014, while the trip colored 
in blue occured on the 26th of June 2014. This is necessary because not doing so
leads to  problems such as sudden jumps in the vessel-position (visible from the
straight diagonal line in the Tracks plot). The transformation from a  vessel 
trajectory to trips is implemented in the `Trajectory2Trips()` function  further
below. The functions goes even one step further and subdivides trips occuring at
different days into outbound and inbound trips.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
tmp <- filter(aisdata, MMSI == 224548000, LON > -15.44 , LON < -15.37) %>% 
  mutate(daytrip = as.factor(day(TIMESTAMP)))
tmp_p1 <- ggplot(tmp) +
  geom_point(aes(LON, LAT)) + 
  ggtitle('Points') + coord_fixed()
tmp_p2 <- ggplot(tmp) + 
  geom_point(aes(LON, LAT)) + 
  geom_path(aes(LON, LAT)) + 
  ggtitle('Tracks') + coord_fixed()
tmp_p3 <- ggplot() + 
  geom_point(data = tmp, aes(LON, LAT, color = daytrip)) +
  geom_path(data = tmp, aes(LON, LAT, color = daytrip)) + 
  ggtitle('Trips') + theme(legend.position = 'none') + coord_fixed() +
  scale_colour_brewer(palette = "Set1")
tmp_p123 <- grid.arrange(tmp_p1, tmp_p2, tmp_p3, ncol = 3, nrow = 1)
ggsave("figures/point-track-trips.png", plot = tmp_p123)
RemoveObjects('tmp')
```

Here we transform the point representation into a trajectory representation as 
explained before. Very importantly we calculate the duration of each segment on
the trajectory as well as the average speed and bearing. 
```{r, message=FALSE, warning=FALSE, results=FALSE}
Points2Trajectory <- function(df){
  df <- df %>% arrange(TIMESTAMP)  
  idx1 <- seq(1, nrow(df) - 1, 1)
  idx2 <- seq(2, nrow(df), 1) 
  startpoints <- slice(df,idx1) %>% select(START_LON = LON, START_LAT = LAT)
  endpoints <- slice(df,idx2) %>% select(END_LON = LON, END_LAT = LAT)
  start_time <- slice(df,idx1) %>% .$TIMESTAMP
  end_time <- slice(df,idx2) %>% .$TIMESTAMP
  data.frame(slice(df,idx1) %>% select(MMSI),
             slice(df,idx1) %>% select(START_POSID = POSID),
             slice(df,idx2) %>% select(END_POSID = POSID),
             TIME_START = start_time,
             TIME_END = end_time,
             startpoints,
             endpoints,
             DISTANCE = distCosine(startpoints, endpoints),
             BEARING = bearing(startpoints, endpoints),
             TIME_DIFF = as.numeric(end_time - start_time, units = "secs")
             ) %>% 
  mutate(AVG_SPEED = DISTANCE / TIME_DIFF,
         TIME_DIFF_MIN = round((TIME_DIFF/60)))
}
trajectories <- aisdata %>% group_by(MMSI) %>% 
  do(Points2Trajectory(.)) %>% as.data.frame()
# ExportObject(trajectories)
```


#### Detect trips
We divide each vessel's trajectory into a collection of trips. We do this based 
on the time difference between subsequent  location measurements. In 
other words if the time difference between two measurements exceeds a certain
value then it is assumed that the current vessel's trip has ended and a new trip
has started. This may be the case when a vessel either leaves the port area or
turns off its AIS transmitter.

But first we must determine the the time threshold to determine where a 
trajectory needs to be split or not. We do this by plotting the proportion of
time differences observed between each measurement using a subselection of the 
data. 

This subselection of data uses contains only vessels in the immediate proximity
of the port. By doing this we are more likely to have data where the time
difference is unaffected by unwanted factors (e.g. signal disturbances). (TODO
insert ref on better signal near coasts) and therefore unbiased.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Temporary subselection of data
tmp_trajectories_port <- trajectories %>%
  filter(START_LON > -15.45, START_LON < -15.37)  %>%
  filter(START_LAT > 28.1, START_LAT < 28.1507) %>%
  filter(END_LON > -15.45, END_LON < -15.37)  %>%
  filter(END_LAT > 28.1, END_LAT < 28.1507) %>%
  filter( (day(TIME_START) - day(TIME_END)) < 2 )  # To avoid day jumps.

# ExportObject(select(tmp_trajectories_port,START_LON, START_LAT))
# Discard uncommon measurements
tmp_test <- tmp_trajectories_port  %>% 
  count(TIME_DIFF_MIN) %>%
  mutate(prop = n/sum(n)*100) %>% 
  filter(prop > .5)

# Plot time differentials
ggplot(data = tmp_test) + 
  geom_col(mapping = aes(x = TIME_DIFF_MIN, y = prop)) +
  scale_x_continuous(breaks = seq(1:32)) +
  ylim(0, 35) +
  labs(title = paste("Time difference between measurements. \nn = ", 
                     nrow(tmp_trajectories_port), 
                     'with',round(sum(tmp_test$prop),1),'% of the data shown'), 
       x = "Time between subsequent measurements (minutes)", 
       y = "Proportion of data (%)") +
  geom_label(aes(label = paste(round(prop,1),'%'), x = TIME_DIFF_MIN, y = prop + 1 ),
             vjust = 0.3, size = 3, label.padding = unit(0.15, "lines"))
RemoveObjects('tmp')
```
The plot above tells us how many minute pass between subsequent measurements and
how much of the sampled data occurs within a given time interval. For instance
we can see that 32.5% of the measurements occur in 21 minute intervals. Overall
for 96.1% of the sampled data less than 30 minutes pass between subsequent
measurements. Note that sampling rates that occur in less than 0.5% of the
sampled data were excluded.

This data suggests that the sampling intervals 

CONTINUE HERE!

```{r}
tmp2 <- filter(tmp_trajectories_port, TIME_DIFF_MIN == 30)
tmp3 <- select(tmp2,MMSI) %>% unique.data.frame()
tmp_vesseldetails <- left_join(tmp3, vesseldetails, by = 'MMSI')
tmp_vesseldetails
```


This function splits a vessel's trajetory  consisting of one long sequence of timestamped coordinates at major  discontinuities in time (using interquartiles and the average time differential  between tracks) as well as when a vessel stops for a significant amount of time. First we convert the AIS measurements (GPS coordinates) into a collection of tracks. We have one track per vessel. A vessel's track consists of a continuous series of segments with a start and end point, a duration etc. Of particular importance is the duration (`TIME_DIFF`) we calculate below. This tells us the  time passed between consecutive measurements. If this time is significantly larger  spike in terms of this time it means that a vessel may have left the area from  which the data was collected and returned at a later date or that the AIS signal was lost for other reasons.
```{r}
Trajectory2Trips <- function(df){
  result <- c(1:nrow(df))
  threshold <- quantile(df$TIME_DIFF, probs = c(.95), type = 8)
  counter <- 1
  for (i in 1:nrow(df)) {
    if (df$TIME_DIFF[i] <= threshold){
      result[i] <- counter  
    }else{
      result[i] <- -1
      counter <- counter + 1
    }
  }
  data.frame(result)
}
```

```{r}
trips <- trajectories %>% 
  group_by(MMSI) %>% 
  do(Trajectory2Trips(.)) %>% 
  as.data.frame() %>% 
  select(result) %>% 
  cbind(trajectories, TRIP_ID = .$result) 
```

